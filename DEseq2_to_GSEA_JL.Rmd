---
title: "From DEseq2 to GSEA"
author: "Julio_Leon"
date: "10/15/2020","10/30/2020"
output: html_document
---

# Differential Gene expression and DEseq2

-   Test tens of thousands of hypotheses (one test for each gene)

-   Limited number of biological replicates, non-normality of the distribution of the read counts, and higher uncertainty of measurements for lowly expressed genes than highly expressed genes

-   These models assume that for each gene, the read counts are generated by a negative binomial distribution

## Negative Binomial model

![](images/paste-D6C48994.png){width="394"}

-   The more variance the more dispersion. Higher mean, less dispersion

## Normalization

1.  library depth or size . (sequence depth = number of reads)

    Differences in library size can lead to more reads being aligned to one sample vs another         sample → we need to adjust this based on the size of the library

2.  Gene length 

      A longer gene generates a longer transcript and more fragments for sequencing.

      A longer gene will often have more counts than a shorter gene with the same level of expression

      Since DE compares between two or more conditions, we do not need to normalize for gene length. however if you need to compare for different gene expressions within a sample we will need to normalize for gene length

3.RNA composition (library composition)

      takes up larger proportion of reads sample A. If we divide by total number of reads, most of genes will be skewed by the highly express gene

### DEseq2 Normalization

-   Deseq uses median of rations for normalization: it adjust for library size and is resistant to outlier genes

```{r}
library(DESeq2)
install.packages("remotes")
remotes::install_github("compgenomr/compGenomRData")
```

```{r}
counts_file <- system.file("extdata/rna-seq/SRP029880.raw_counts.tsv",
                           package = "compGenomRData")
coldata_file <- system.file("extdata/rna-seq/SRP029880.colData.tsv",
                            package = "compGenomRData")
counts <- as.matrix(read.table(counts_file, header = T, sep = '\t'))

metadata <- as.matrix(read.table(coldata_file, header = T, sep = '\t'))

```

```{r}
countData <- as.matrix(subset(counts, select = c(-width)))

```

\#create deseq2 object

```{r}
dds <- DESeqDataSetFromMatrix(countData = countData, 
                              colData = metadata, 
                              design = ~group)
```

```{r}
dds <- dds[ rowSums(DESeq2::counts(dds)) > 1, ]
```

\#Perform DE analysis

```{r echo=TRUE}
dds <- DESeq(dds)
```

```{r}
DEresults = results(dds, contrast = c("group", 'CASE', 'CTRL'), alpha = 0.05)
```

![](images/paste-FC57B161.png)

```{r}
plotMA(DEresults)
summary(DEresults)

```

```{r}
DE_results <- data.frame(DEresults) 

```

### GSEA analysis

-   It is a computational method that determines whether an *a priori* defined set of genes shows statistically significant, concordant differences between two biological states (e.g. phenotypes)

    -   Requirements:

        1\. A ranked gene list

        2\. Set of pre-determined genes

        ![](images/paste-A9EF136B.png)

**Calculation of an Enrichment Score.** "We calculate an enrichment score (ES) that reflects the degree to which a set S is overrepresented at the extremes (top or bottom) of the entire ranked list L".

The score is calculated by walking down the list L, increasing a running-sum statistic when we encounter a gene in S and decreasing it when we encounter genes not in S.

*\>\>In few words: Is this gene predetermined set of genes present in the ranked list? if present, what is its weigh in the ranked list? Adding- up!*

**NES:** normalize the ES for each gene set to account for the size of the set.

**FDR(padj):** is the estimated probability that a set with a given NES represents a false positive finding

**The Leading-Edge Subset:** We define the leading-edge subset to be those genes in the gene set S that appear in the ranked list L at, or before, the point where the running sum reaches its maximum deviation from zero

*\>\> In few words: is the core of a gene set that accounts for the enrichment signal*

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
library(dplyr)
  library(ggplot2)
  library(fgsea)
```

```{r}
DE_results_0.1 <- DE_results %>% filter(padj<0.1)
DE_results_0.1 <- DE_results_0.1 %>% rownames_to_column(var = "symbol")
S4table = DE_results_0.1 %>% 
filter(symbol != "")
gene_list = S4table$log2FoldChange
names(gene_list) = S4table$symbol
gene_list = sort(gene_list, decreasing = TRUE)
gene_list = gene_list[!duplicated(names(gene_list))]
head(gene_list)
gene_list
```

```{r echo=TRUE}
myGO = fgsea::gmtPathways("/Users/julio.l/Documents/GitHub/Learning/c5.bp.v7.1.symbols.gmt")
fgRes <- fgsea::fgsea(pathways =myGO, 
                           stats = gene_list,
                           minSize=15,
                           maxSize=1000,
                      eps = 0) 


```

# To select only independent pathways one can use collapsePathways function:

```{r}
collapsedPathways <- collapsePathways(fgRes, 
                                      myGO, gene_list)
mainPathways <- fgRes[pathway %in% collapsedPathways$mainPathways][
                         order(-NES), pathway]
mainPathways <- as.data.frame(mainPathways)

fgResmain <- fgRes %>% filter(pathway %in% mainPathways$mainPathways)
```

```{r}

feres_0.1 <- fgRes %>% filter(padj < 0.1)

```
